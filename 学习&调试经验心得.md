- ### USmart函数的使用  usmart.c 三个函数 +一个串口接收函数

串口接收函数需要配合原子家自己的接收协议（回车那个）

一个函数用来初始化中断用来实现串口数据处理 。

另外两个函数一个是用来算程序运行时间的（根据所使用的MUC时钟来修改）

usmart_scan 两个参数 一个是串口数据 一个是串口接收状态  

具体修改在 usmart_config.中加头文件加按格式写好的函数名

list 打印所有函数

id  获取入口地址  

help  帮助信息

hex dec 十进制十六进制转换

runtime 1/0  开启或关闭 函数时间计时功能

带有函数参数的函数的调用  利用id获取函数参数地址   使用方法函数（地址，参数）




-  ### 高级定时器 1&8 

8个通道

16位定时器  由一个可编程预分频器驱动（16位）

脉冲宽度捕获 。产生波形 （N多功能 PWM 死区时间互补PWM 和H桥和半H桥有关  上下桥臂不是同时输出 造成差异）

周期由两个分频器控制。 高级定时器和通用定时器互相独立。




-  ### USART和UART

universal asynchronous reciver and transmitter    通用异步收发器

universal synchronous asynchronous receiver and transmitter  通用同步异步收发器

USART 支持同步模式，因此USART 需要同步始终信号USART_CK（单片机可发送），通常情况下同步信号很少使用，因此单片机的UART和

USART使用方式差不多，都是用异步模式进行收发。



-  ### 堆 FIFO  栈 FILO

心得：对于搞嵌入式的人来所，嵌入式系统的内存是宝贵的，内存是否高效率的使用往往意味着嵌入式设备是否高质量和高性能，

所以高效的使用内存对我们来说是很重要的。



-  ###  Git

.gitignore 用于忽略你不想提交到Git上的文件

.gitattribute 指定非文本文件的对比合并方式 

pull是从remote repo拉取local branch的最新代码下到local repo；

fetch是从remote repo拉取other branches的最新代码下到local repo。





-  ### ESP8266 

AT指令固件包  NodeMCU固件包

芯片是乐鑫的  模组是安信可的  

ESP8266 也可以用SPI进行通信开发（未完待续）：

CPOL控制空闲时的电平状态，CPHA控制数据在CLK第几个沿开始传输。

高位开始传输

-  ### FreeRTOS

利用STM32CubeMX 进行基本配置 

首先配置始终，选择外部晶振输入，然后配置两个IO口并改标签。然后使能FreeRTOS。

切换第二个表卡，点击图标。Config parameters
是配置参数，列出了FREERTOS中可配置的参数，对应FreeTTRTOSConfig.h中的参数

Include parameters 选项卡的参数是用来配置裁剪系统的。

Tasks and Queues 用于添加任务和队列

Timers and Semaphores 是添加软件定时器和信号量的选项 


-  ### JTAG JLINK SWD  下载调试

JLINK是利用STM32的JTAG口进行下载和调试的。 

使用了JLINK V7版本（利用的是之前飞思卡尔 Zigbee开发板送的） 

 用了四根线  VCC GND CLK SWDDIO 。发现下载不进去 提示尝试Reset。 因为仿真器没有这个脚。手按着开发板的复位键也不行。

MDK 设置Reset模式也没用 。网上说与一种system reset 模式和  vect reset 都没有找到。 仿真器的reset 脚接开发板的reset脚 。不就是控制开发板的reset吗

最后没有下载成功。 希望以后能用上高级版本的jink 进行测试。

-  ### STM8

Stm8cubemx 只能生成引脚分配图  不能生成代码

Stm8 AD 配置流程 
- 使能或失能AD外设
- 初始化和配置寄存器，ADC分辨率，ADC转换模式
- 配置外部触发源
- 通过软件设置触发AD转化 

typedef* structure 

structure-> =

typedef structure 

structure. =

-  ### C指针



int *p；p是一个指针变量 需要指向一个地址 （初始化） p就是一个需要被指向整形变量地址的变量。

int *p；
p=&a;
*p++;
print(a)//a=a+1;


在形参中 int *p 就是一个地址。 point( int *p){}

int* p;
p="abcd"; //可行 应为字符串传递值就是字符串的首地址
 
int a[10];
p=a; //数组a的首地址
char *arr[4] = {"hello", "world", "shannxi", "xian"};
//arr就是我定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。
char (*pa)[4];
//pa是一个指针指向一个char数组，每个数组元素是一个char类型的变量

-  ### RS485 

RS485转换器SP3485。其中5脚和8脚是电源引脚；6脚和7脚就是RS485通信中的A和B两个引脚；1脚和4脚分别接到单片机的RXD和TXD引脚上，直接使用单片机UART进行数据接收和发送；2脚和3脚是方向引脚，其中2脚是低电平使能接收器，3脚是高电平使能输出驱动器，我们把这两个引脚连到一起，平时不发送数据的时候，保持这两个引脚是低电平，让MAX485处于接收状态，当需要发送数据的时候，把这个引脚拉高，发送数据，发送完毕后再拉低这个引脚就可以了。为了提高RS485的抗干扰能力，需要在靠近MAX485的A和B引脚之间并接一个电阻，这个电阻阻值从100欧到1K都是可以。







-  ### 差分信号

任何两个信号都可以分解为共模信号和差模信号。共模信号是作用在差分放大器或仪表放大器两个输入端的相同信号，通常是由于线路传导和空间磁场干扰产生的，是不希望出现的信号，差模信号是两个输入端信号的相位相差180度。如果共模信号被放大很多，会影响到真正需要放大的差模信号。设两路的输入信号分别为： A,B，分别表示为：A=m+n；B=m-n，则输入信号A,B可以看成一个共模信号 m 和差模信号 n 的合成，其中m=(A+B)/2；n=(A-B)/2。
常用共模抑制比CMRR来衡量差分放大电路抑制共模信号的能力，它是放大器对差模信号的电压放大倍数与对共模信号的电压放大倍数之比，CMRR越大，放大器的性能越好。

在差分放大电路中，无论是温度变化，还是电源电压的波动等，都会引起两管（两特性相同的三端器件所组成的差分放大电路的输入端）集电极电流以及相应的集电极电压相同的变化，其效果相当于在两个输入端加入了共模信号。温度变化、电源电压的波动等引起的信号变化当然要加以抑制，所以要抑制共模信号。
常用共模抑制比作为一项衡量差分放大电路抑制共模信号的能力的技术指标，其定义为：放大电路差模信号的电压增益与共模信号的电压增益之比的绝对值。共模抑制比愈高，抑制共模信号的能力越强。





