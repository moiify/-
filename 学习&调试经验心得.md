- ### USmart函数的使用  usmart.c 三个函数 +一个串口接收函数

串口接收函数需要配合原子家自己的接收协议（回车那个）

一个函数用来初始化中断用来实现串口数据处理 。

另外两个函数一个是用来算程序运行时间的（根据所使用的MUC时钟来修改）

usmart_scan 两个参数 一个是串口数据 一个是串口接收状态  

具体修改在 usmart_config.中加头文件加按格式写好的函数名

list 打印所有函数

id  获取入口地址  

help  帮助信息

hex dec 十进制十六进制转换

runtime 1/0  开启或关闭 函数时间计时功能

带有函数参数的函数的调用  利用id获取函数参数地址   使用方法函数（地址，参数）




-  ### 高级定时器 1&8 

8个通道

16位定时器  由一个可编程预分频器驱动（16位）

脉冲宽度捕获 。产生波形 （N多功能 PWM 死区时间互补PWM 和H桥和半H桥有关  上下桥臂不是同时输出 造成差异）

周期由两个分频器控制。 高级定时器和通用定时器互相独立。




-  ### USART和UART

universal asynchronous reciver and transmitter    通用异步收发器

universal synchronous asynchronous receiver and transmitter  通用同步异步收发器

USART 支持同步模式，因此USART 需要同步始终信号USART_CK（单片机可发送），通常情况下同步信号很少使用，因此单片机的UART和

USART使用方式差不多，都是用异步模式进行收发。



-  ### 堆 FIFO  栈 FILO

心得：对于搞嵌入式的人来所，嵌入式系统的内存是宝贵的，内存是否高效率的使用往往意味着嵌入式设备是否高质量和高性能，

所以高效的使用内存对我们来说是很重要的。



-  ###  Git

.gitignore 用于忽略你不想提交到Git上的文件

.gitattribute 指定非文本文件的对比合并方式 

pull是从remote repo拉取local branch的最新代码下到local repo；

fetch是从remote repo拉取other branches的最新代码下到local repo。





-  ### ESP8266 

AT指令固件包  NodeMCU固件包

芯片是乐鑫的  模组是安信可的  

ESP8266 也可以用SPI进行通信开发（未完待续）：

CPOL控制空闲时的电平状态，CPHA控制数据在CLK第几个沿开始传输。

高位开始传输

-  ### FreeRTOS

利用STM32CubeMX 进行基本配置 

首先配置始终，选择外部晶振输入，然后配置两个IO口并改标签。然后使能FreeRTOS。

切换第二个表卡，点击图标。Config parameters
是配置参数，列出了FREERTOS中可配置的参数，对应FreeTTRTOSConfig.h中的参数

Include parameters 选项卡的参数是用来配置裁剪系统的。

Tasks and Queues 用于添加任务和队列

Timers and Semaphores 是添加软件定时器和信号量的选项 


-  ### JTAG JLINK SWD  下载调试

JLINK是利用STM32的JTAG口进行下载和调试的。 

使用了JLINK V7版本（利用的是之前飞思卡尔 Zigbee开发板送的） 

 用了四根线  VCC GND CLK SWDDIO 。发现下载不进去 提示尝试Reset。 因为仿真器没有这个脚。手按着开发板的复位键也不行。

MDK 设置Reset模式也没用 。网上说与一种system reset 模式和  vect reset 都没有找到。 仿真器的reset 脚接开发板的reset脚 。不就是控制开发板的reset吗

最后没有下载成功。 希望以后能用上高级版本的jink 进行测试。

-  ### STM8

Stm8cubemx 只能生成引脚分配图  不能生成代码

Stm8 AD 配置流程 
- 使能或失能AD外设
- 初始化和配置寄存器，ADC分辨率，ADC转换模式
- 配置外部触发源
- 通过软件设置触发AD转化 

typedef* structure 

structure-> =

typedef structure 

structure. =

-  ### C指针



int *p；p是一个指针变量 需要指向一个地址 （初始化） p就是一个需要被指向整形变量地址的变量。

int *p；
p=&a;
*p++;
print(a)//a=a+1;


在形参中 int *p 就是一个地址。 point( int *p){}

int* p;
p="abcd"; //可行 应为字符串传递值就是字符串的首地址
 
int a[10];
p=a; //数组a的首地址
char *arr[4] = {"hello", "world", "shannxi", "xian"};
//arr就是我定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。
char (*pa)[4];
//pa是一个指针指向一个char数组，每个数组元素是一个char类型的变量








